/**
 * API è¿æ¥æµ‹è¯•çš„å·¥å…·å‡½æ•°
 */

export const testApiConnection = async () => {
  const baseUrl = process.env.NEXT_PUBLIC_API_BASE_URL || '/api';
  console.log('ğŸ§ª å¼€å§‹ API è¿æ¥æµ‹è¯•...');
  console.log('ğŸ”— åŸºç¡€ URL:', baseUrl);

  try {
    // 1. åŸºç¡€ API è·¯å¾„æµ‹è¯•
    const healthCheckUrl = `${baseUrl}/health`;
    console.log('ğŸ“¡ å¥åº·æ£€æŸ¥è¯·æ±‚:', healthCheckUrl);
    
    const healthResponse = await fetch(healthCheckUrl, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
      },
    });
    
    console.log('ğŸ“Š å¥åº·æ£€æŸ¥å“åº”:', {
      status: healthResponse.status,
      statusText: healthResponse.statusText,
      headers: Object.fromEntries(healthResponse.headers.entries()),
    });

    // 2. è¯¾ç¨‹ API æµ‹è¯•
    const coursesUrl = `${baseUrl}/courses`;
    console.log('ğŸ“¡ è¯¾ç¨‹ API è¯·æ±‚:', coursesUrl);
    
    const coursesResponse = await fetch(coursesUrl, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
      },
    });
    
    console.log('ğŸ“Š è¯¾ç¨‹ API å“åº”:', {
      status: coursesResponse.status,
      statusText: coursesResponse.statusText,
      headers: Object.fromEntries(coursesResponse.headers.entries()),
    });

    if (coursesResponse.ok) {
      const coursesData = await coursesResponse.json();
      console.log('âœ… è¯¾ç¨‹æ•°æ®:', coursesData);
    }

    return {
      healthCheck: healthResponse.status,
      coursesApi: coursesResponse.status,
    };
  } catch (error) {
    console.error('âŒ API æµ‹è¯•å‡ºé”™:', error);
    throw error;
  }
};

export const testSpecificCourseUpdate = async (courseId: string) => {
  const baseUrl = process.env.NEXT_PUBLIC_API_BASE_URL || '/api';
  const updateUrl = `${baseUrl}/courses/${courseId}`;
  
  console.log('ğŸ§ª æµ‹è¯•ç‰¹å®šè¯¾ç¨‹æ›´æ–° URL:', updateUrl);
  
  try {
    // OPTIONS è¯·æ±‚æ£€æŸ¥å…è®¸çš„æ–¹æ³•
    const optionsResponse = await fetch(updateUrl, {
      method: 'OPTIONS',
    });
    
    console.log('ğŸ“Š OPTIONS å“åº”:', {
      status: optionsResponse.status,
      headers: Object.fromEntries(optionsResponse.headers.entries()),
    });
    
    return optionsResponse.status;
  } catch (error) {
    console.error('âŒ OPTIONS è¯·æ±‚å¤±è´¥:', error);
    throw error;
  }
};

export const validateFormData = (formData: FormData) => {
  console.log('ğŸ” å¼€å§‹è¡¨å•æ•°æ®éªŒè¯...');
  
  const requiredFields = ['title', 'description', 'category', 'price', 'status'];
  const missingFields: string[] = [];
  
  for (const field of requiredFields) {
    const value = formData.get(field);
    if (!value || (typeof value === 'string' && !value.trim())) {
      missingFields.push(field);
    }
  }
  
  if (missingFields.length > 0) {
    console.error('âŒ ç¼ºå°‘å¿…å¡«å­—æ®µ:', missingFields);
    return {
      isValid: false,
      missingFields,
    };
  }
  
  console.log('âœ… è¡¨å•æ•°æ®éªŒè¯é€šè¿‡');
  return {
    isValid: true,
    missingFields: [],
  };
};
// ==============================
// üîê Auth ÂåÖÁã¨Á´ãÊ®°ÂºèÂÆö‰πâ
// ‰∏∫Èò≤Ê≠¢Âæ™ÁéØ‰æùËµñËÄåÁã¨Á´ãÂÆö‰πâ
// ==============================

import { z } from 'zod';

// ==============================
// Âü∫Á°ÄÈ™åËØÅÊ®°Âºè
// ==============================

export const emailSchema = z
  .string()
  .min(1, 'ËØ∑ËæìÂÖ•ÈÇÆÁÆ±')
  .email('ÈÇÆÁÆ±Ê†ºÂºè‰∏çÊ≠£Á°Æ')
  .max(255, 'ÈÇÆÁÆ±Â§™Èïø');

export const passwordSchema = z
  .string()
  .min(8, 'ÂØÜÁ†ÅËá≥Â∞ëÈúÄË¶Å8‰∏™Â≠óÁ¨¶')
  .max(128, 'ÂØÜÁ†ÅÂ§™Èïø')
  .regex(
    /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/,
    'ÂØÜÁ†ÅÂøÖÈ°ªÂåÖÂê´Â§ßÂ∞èÂÜôÂ≠óÊØç„ÄÅÊï∞Â≠óÂíåÁâπÊÆäÂ≠óÁ¨¶'
  );

export const usernameSchema = z
  .string()
  .min(2, 'Áî®Êà∑ÂêçËá≥Â∞ëÈúÄË¶Å2‰∏™Â≠óÁ¨¶')
  .max(50, 'Áî®Êà∑ÂêçÂ§™Èïø')
  .regex(/^[a-zA-Z0-9_-]+$/, 'Áî®Êà∑ÂêçÂè™ËÉΩ‰ΩøÁî®Ëã±Êñá„ÄÅÊï∞Â≠ó„ÄÅ‰∏ãÂàíÁ∫øÂíåËøûÂ≠óÁ¨¶')
  .optional();

export const nameSchema = z
  .string()
  .min(1, 'ËØ∑ËæìÂÖ•ÂßìÂêç')
  .max(100, 'ÂßìÂêçÂ§™Èïø')
  .regex(/^[‰∏Ä-Èæ•a-zA-Z\s]+$/, 'ÂßìÂêçÂè™ËÉΩ‰ΩøÁî®‰∏≠Êñá„ÄÅËã±ÊñáÂíåÁ©∫Ê†º');

export const phoneSchema = z
  .string()
  .regex(/^1[3-9]\d{9}$/, 'ËØ∑ËæìÂÖ•Ê≠£Á°ÆÁöÑÊâãÊú∫Âè∑Á†Å')
  .optional();

// ==============================
// ËÆ§ËØÅÁõ∏ÂÖ≥Ê®°Âºè
// ==============================

export const loginSchema = z.object({
  email: emailSchema,
  password: z.string().min(1, 'ËØ∑ËæìÂÖ•ÂØÜÁ†Å'),
}).strict();

export const registerSchema = z.object({
  email: emailSchema,
  password: passwordSchema,
  username: usernameSchema.optional(),
  name: nameSchema.optional(),
}).strict();

export const refreshTokenSchema = z.object({
  refreshToken: z.string().min(1, 'ÈúÄË¶ÅÂà∑Êñ∞‰ª§Áâå'),
}).strict();

export const changePasswordSchema = z.object({
  currentPassword: z.string().min(1, 'ËØ∑ËæìÂÖ•ÂΩìÂâçÂØÜÁ†Å'),
  newPassword: passwordSchema,
}).strict();

export const forgotPasswordSchema = z.object({
  email: emailSchema,
}).strict();

export const resetPasswordSchema = z.object({
  token: z.string().min(1, 'ÈúÄË¶Å‰ª§Áâå'),
  newPassword: passwordSchema,
}).strict();

export const verifyEmailSchema = z.object({
  token: z.string().min(1, 'ÈúÄË¶ÅÈ™åËØÅ‰ª§Áâå'),
}).strict();

export const socialAuthCallbackSchema = z.object({
  code: z.string().min(1, 'ÈúÄË¶ÅËÆ§ËØÅÁ†Å'),
  state: z.string().optional(),
}).strict();

export const updateProfileSchema = z.object({
  username: usernameSchema,
  name: nameSchema.optional(),
  phone: phoneSchema,
}).strict();

export const updateSettingsSchema = z.object({
  notifications: z.boolean().optional(),
  theme: z.enum(['light', 'dark']).optional(),
  language: z.enum(['zh', 'en']).optional(),
}).strict();

export const deleteAccountSchema = z.object({
  password: z.string().min(1, 'ËØ∑ËæìÂÖ•ÂØÜÁ†Å'),
  confirmText: z.literal('DELETE', {
    errorMap: () => ({ message: 'ËØ∑ÂáÜÁ°ÆËæìÂÖ•DELETE' }),
  }),
}).strict();

export const passwordStrengthSchema = z.object({
  password: z.string(),
}).strict();

// ==============================
// Á±ªÂûãÂÆö‰πâ
// ==============================

export type LoginDto = z.infer<typeof loginSchema>;
export type RegisterDto = z.infer<typeof registerSchema>;
export type RefreshTokenDto = z.infer<typeof refreshTokenSchema>;
export type ChangePasswordDto = z.infer<typeof changePasswordSchema>;
export type ForgotPasswordDto = z.infer<typeof forgotPasswordSchema>;
export type ResetPasswordDto = z.infer<typeof resetPasswordSchema>;
export type VerifyEmailDto = z.infer<typeof verifyEmailSchema>;
export type SocialAuthCallbackDto = z.infer<typeof socialAuthCallbackSchema>;
export type UpdateProfileDto = z.infer<typeof updateProfileSchema>;
export type UpdateSettingsDto = z.infer<typeof updateSettingsSchema>;
export type DeleteAccountDto = z.infer<typeof deleteAccountSchema>;

// ==============================
// ËÆ§ËØÅÂìçÂ∫îÁ±ªÂûã
// ==============================

export interface AuthTokens {
  accessToken: string;
  refreshToken: string;
  expiresIn: number;
  tokenType: 'Bearer';
}

export interface AuthUser {
  id: string;
  email: string;
  username?: string;
  name?: string;
  role: string;
  isEmailVerified: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface AuthResponse {
  success: boolean;
  message: string;
  data?: any;
}

export interface LoginResponse extends AuthResponse {
  data: {
    user: AuthUser;
    tokens: AuthTokens;
  };
}

export interface RegisterResponse extends AuthResponse {
  data: {
    user: AuthUser;
    tokens: AuthTokens;
  };
}

export interface AuthError {
  message: string;
  code: string;
  statusCode: number;
}

export interface TokenPayload {
  sub: string;
  email: string;
  role: string;
  iat: number;
  exp: number;
}

export interface SessionInfo {
  id: string;
  userId: string;
  ipAddress: string;
  userAgent: string;
  isActive: boolean;
  lastAccessedAt: string;
}

export interface PasswordStrengthResult {
  score: number; // 0-4
  feedback: string[];
  isStrong: boolean;
}

// ==============================
// Â∑•ÂÖ∑ÂáΩÊï∞
// ==============================

export function sanitizeUserResponse(user: any): AuthUser {
  return {
    id: user.id,
    email: user.email,
    username: user.username,
    name: user.name,
    role: user.role,
    isEmailVerified: user.isEmailVerified,
    createdAt: user.createdAt,
    updatedAt: user.updatedAt,
  };
}

export function validatePassword(password: string): boolean {
  try {
    passwordSchema.parse(password);
    return true;
  } catch {
    return false;
  }
}

export function validateEmail(email: string): boolean {
  try {
    emailSchema.parse(email);
    return true;
  } catch {
    return false;
  }
}